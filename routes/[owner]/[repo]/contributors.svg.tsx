import { h, renderSSR, Component } from 'nano-jsx';
import { chunk } from 'lodash-es';
import { fromByteArray as base64 } from 'base64-js';

interface Contributor {
  login: string;
  id: number;
  avatar_url: string;
  html_url: string;
  type: 'User' | 'Anonymous' | 'Bot';
  email?: string;
  name?: string;
  contributions: number;
}

export default eventHandler(async e => {
  const query = new URL(e.node.req.url, `http://${e.node.req.headers['host']}`)
    .searchParams;

  const width = parseInt(query.get('width') ?? '800');
  const bot = query.get('bot') === 'true';
  const pad = parseInt(query.get('pad') ?? '8');
  const margin = parseInt(query.get('margin') ?? '8');
  const size = parseInt(query.get('size') ?? '64');
  const max = parseInt(query.get('max') ?? '100');
  const hideBorder = query.get('hide_border') === 'true';
  const borderColor = query.get('border_color') ?? '#c0c0c0';
  const maxage = parseInt(query.get('maxage') ?? '7200');

  const { owner, repo } = e.context.params;

  let contributors: Contributor[] = [];
  const perPage = max > 100 ? 100 : max;
  let page = 1;
  while (contributors.length < max) {
    let list = await listRepositoryContributors(owner, repo, page, perPage);
    page++;
    contributors.push(...(bot ? list : list.filter(c => c.type !== 'Bot')));
    if (list.length < perPage) break;
  }
  if (contributors.length > max) contributors = contributors.slice(0, max);

  contributors = contributors.sort((a, b) => b.contributions - a.contributions);
  contributors = await resolveAvatars(contributors, size);

  class SVG extends Component {
    height = 0;
    components = [];

    render() {
      this.height += margin;

      const colMax = Math.floor((width - margin * 2 + pad) / (size + pad));
      const rowCount = Math.ceil(contributors.length / colMax);

      chunk(contributors, colMax).map((chunk, i) => {
        this.height += size / 2;
        const offset =
          (width - chunk.length * (size + pad)) / 2 + (size + pad) / 2;
        chunk.map((c, j) => {
          const x = offset + (size + pad) * j;
          this.components.push(
            <pattern
              id={`avatar_${c.id}`}
              x={x - size / 2}
              y={this.height - size / 2}
              width={size}
              height={size}
              patternUnits="userSpaceOnUse"
            >
              <image
                x={0}
                y={0}
                width={size}
                height={size}
                xlink:href={c.avatar_url}
              />
            </pattern>
          );
          this.components.push(
            <circle
              r={size / 2}
              cx={x}
              cy={this.height}
              fill={`url(#avatar_${c.id})`}
              stroke={borderColor}
              stroke-width={hideBorder ? 0 : 1}
            />
          );
        });
        this.height += size / 2;
        if (i < rowCount - 1) this.height += pad;
      });

      this.height += margin;
      return (
        <svg
          width={width}
          height={this.height}
          viewBox={`0 0 ${width} ${this.height}`}
          xmlns="http://www.w3.org/2000/svg"
          xmlns:xlink="http://www.w3.org/1999/xlink"
        >
          {this.components}
        </svg>
      );
    }
  }

  e.node.res.appendHeader('accept-encoding', 'br');
  e.node.res.appendHeader('content-type', 'image/svg+xml');
  e.node.res.appendHeader(
    'cache-control',
    `max-age=${maxage}, s-maxage=${maxage}`
  );
  return (
    '<!-- Generated by gizmo-ds/contributors.svg -->\n' + renderSSR(() => SVG)
  );
});

function resolveAvatars(contributors: Contributor[], size: number) {
  return Promise.all(
    contributors.map(async c => {
      const u = new URL(c.avatar_url);
      u.searchParams.set('size', size.toString());
      const data = await fetch(u.toString()).then(async resp => ({
        contentType: resp.headers.get('content-type'),
        data: new Uint8Array(await resp.arrayBuffer())
      }));
      c.avatar_url = `data:${data.contentType};base64,${base64(data.data)}`;
      return c;
    })
  );
}

async function listRepositoryContributors(
  owner: string,
  repo: string,
  page = 1,
  perPage = 100
) {
  const token = process.env.GITHUB_TOKEN;
  const query = new URLSearchParams({
    anon: '0',
    per_page: perPage.toString(),
    page: page.toString()
  });
  return (await fetch(
    `https://api.github.com/repos/${owner}/${repo}/contributors?${query.toString()}`,
    {
      headers: {
        Accept: 'application/vnd.github+json',
        'X-GitHub-Api-Version': '2022-11-28',
        Authorization: token ? `Bearer ${token}` : undefined
      }
    }
  ).then(resp => {
    if (resp.status !== 200) throw new Error(resp.statusText);
    return resp.json();
  })) as Contributor[];
}
